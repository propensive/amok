version  1
title    A Higher Standard of Standard Library
format   presentation
##

# A HIGHER STANDARD
## of
# STANDARD LIBRARY

---

## The Soundness Backstory

---

## Soundness

- over 100 libraries or modules
- reimplements large parts of the Java and Scala standard libraries
- and other parts of the Java and Scala ecosystem


---

## Two Golden Rules

- Impossible states must be unrepresentable
- Transitions between states must be total

---

## Ten Sample libraries

- _Aviation_ — for working with time, in all its forms
- _Baroque_ — for representing complex numbers
- _Caesura_ — for reading, processing and writing CSV and TSV
- _Dissonance_ — an implementation of Myers' _diff_ algorithm
- _Escritoire_ — for writing tables (to the console)
- _Fulminate_ — providing rich user-facing messages (e.g. for errors)
- _Guillotine_ — for executing shell commands
- _Hyperbole_ — decomposing and presenting TASTy trees
- _Iridescence_ — for representing and transforming colors and color models
- _Jacinta_ — another JSON library

---

![Bundles](https://storage.googleapis.com/soundness-data/bundles2.svg)

---

## The `core` Bundle

* safe error-handling
* pretty-printing of stack traces
* typesafe strings
* representation of color
* easy generic derivation
* inline regular expressions
* optional values

---

## Literals

```amok
version
    val url = url"https//github.com/propensive/soundness"
version
    // the URL http//github.com/propensive/soundness is not valid: a colon was expected
    val url = url"https//github.com/propensive/soundness"
version
    val url = url"https://github.com/propensive/soundness"
version
    val url = url"https://github.com/propensive/soundness"
    val date = 2019-Feb-29
version
    val url = url"https://github.com/propensive/soundness"

    // the date was not valid because 2019-2-29 does not exist in the calendar Gregorian
    val date = 2019-Feb-29
version
    val url = url"https://github.com/propensive/soundness"
    val date = 2020-Feb-29
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 15.20.am
version
    val url = url"https://github.com/propensive/soundness"

    // a time cannot have an hour value above 12
    val time = 2020-Feb-29 at 15.20.am
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Lyon"
version
    val url = url"https://github.com/propensive/soundness"

    // the name Europe/Lyon does not refer to a known timezone
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Lyon"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Th("Key"), Td("Value"))
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"

    // Type mismatch
    val html = Table(Th("Key"), Td("Value"))
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.0.1"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))

    // the IP address is not valid because the address contains 5 period-separated
    // groups instead of 4
    val ip = ip"192.168.0.0.1"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd4"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"

    // the color must be in the form rgb"#rrggbb" or rgb"rrggbb" where rr, gg and bb
    // are 2-digit hex values
    val color = rgb"#40c9cd4"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important."
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"

    // the closing bracket does not match an opening bracket
    val message = e"This is $Bold[$color[very] important."
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/jon"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."

    // application/jon is not a registered media type; did you mean application/json or
    // application/x-jon?
    val mime = media"application/jon"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter 'name='$name'"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"

    // the single quotes have not been closed
    val cmd = sh"docker ps --filter 'name='$name'"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter name=$name"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter name=$name"
    val encoding = enc"ISO-8559-1"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter name=$name"

    // the encoding ISO-8559-1 was not available
    val encoding = enc"ISO-8559-1"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter name=$name"
    val encoding = enc"ISO-8859-1"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter name=$name"
    val encoding = enc"ISO-8859-1"
    val regex = r"hello [a-z]+)"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter name=$name"
    val encoding = enc"ISO-8859-1"

    // the regular expression could not be parsed because a closing parenthesis
    // was found without a corresponding opening parenthesis
    val regex = r"hello [a-z]+)"
version
    val url = url"https://github.com/propensive/soundness"
    val time = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html = Table(Tr(Th("Key"), Td("Value")))
    val ip = ip"192.168.0.1"
    val color = rgb"#40c9cd"
    val message = e"This is $Bold[$color[very] important]."
    val mime = media"application/json"
    val cmd = sh"docker ps --filter name=$name"
    val encoding = enc"ISO-8859-1"
    val regex = r"hello ([a-z]+)"
version
    val url: HttpUrl = url"https://github.com/propensive/soundness"
    val time: Moment = 2020-Feb-29 at 3.20.pm in tz"Europe/Paris"
    val html: Element["table"] = Table(Tr(Th("Key"), Td("Value")))
    val ip: Ipv4 = ip"192.168.0.1"
    val color: Rgb24 = rgb"#40c9cd"
    val message: Teletype = e"This is $Bold[$color[very] important]."
    val mime: MediaType = media"application/json"
    val cmd: Command = sh"docker ps --filter name=$name"
    val encoding: Encoding = enc"ISO-8859-1"
    val regex: Regex = r"hello ([a-z]+)"
```

---

## Regular expressions

```amok
version
    import java.util.regex.*

    case class Email(left: String, right: String)

    object Email:
      val pattern = Pattern.compile("^([^@]+)@([^@]+)$")

      def unapply(email: String): Option[Email] =
        val matcher = pattern.matcher(email)
        if !matcher.matches then None
        else Some(Email(pattern.group(1), pattern.group(2)))

    myEmail match
      case Email(local, domain) =>
        println(t"Local user $local is at domain $domain")
version
    case class Email(left: String, right: String)

    object Email:
      val pattern = Pattern.compile("^([^@]+)@([^@]+)$")

      def unapply(email: String): Option[Email] =
        val matcher = pattern.matcher(email)
        if !matcher.matches then None
        else Some(Email(pattern.group(1), pattern.group(2)))

    myEmail match
      case Email(local, domain) =>
        println(t"Local user $local is at domain $domain")
version
    object Email:
      val pattern = Pattern.compile("^([^@]+)@([^@]+)$")

      def unapply(email: String): Option[Email] =
        val matcher = pattern.matcher(email)
        if !matcher.matches then None
        else Some(Email(pattern.group(1), pattern.group(2)))

    myEmail match
      case Email(local, domain) =>
        println(t"Local user $local is at domain $domain")
version
    object Email:
      val pattern = Pattern.compile("^([^@]+)@([^@]+)$")

    myEmail match
      case Email(local, domain) =>
        println(t"Local user $local is at domain $domain")
version
    object Email:
      val pattern = Pattern.compile("^([^@]+)@([^@]+)$")

    myEmail match
      case r"$local([^@]+)@$domain([^@]+)" =>
        println(t"Local user $local is at domain $domain")
version
    myEmail match
      case r"$local([^@]+)@$domain([^@]+)" =>
        println(t"Local user $local is at domain $domain")
version
    myEmail match
      case r"$local([^@]+)@$domain([^@.]+\.?)*" =>
        println(t"The domain has ${domain.length} parts")
version
    myEmail match
      case r"$local[^@]+@$domain([^@.]+\.?)*" =>
        println(t"The local part is now a list of characters")
```

---

## A "Quality of Life" Feature

```amok
version
    if -1.0 < x && x < 1.0 then x
    else raise(RangeError(x, -1.0, 1.0))
version
    if -1.0 < x < 1.0 then x
    else raise(RangeError(x, -1.0, 1.0))
```

---

## The `data` Bundle

* Myers' _diff_ algorithm
* structural comparison of datatypes
* libraries for working with JSON, XML and CSV/TSV
* BASEn encoding
* tools for working with record types
* cryptographic digests
* encryption and decryption tools

---

## Generic Derivation

- If we have typeclass instances for every parameter of a product type (or every variant of a
  sum type) then we can combine them to create a typeclass instance for the product or sum type.

---

```amok
version
    object Derivation extends Derivable[Inspectable]:
      inline def join[derivation <: Product: ProductReflection]: derivation is Inspectable =
        value =>
          fields(value):
            [field] => field =>
              val text = context.text(field)
              if tuple then text else s"$label:$text"

          . mkString(if tuple then "(" else s"$typeName(", " ╱ ", ")").tt

      inline def split[derivation: SumReflection]: derivation is Inspectable = value =>
        variant(value):
          [variant <: derivation] => variant =>
            context.give(variant.inspect)
```

---

## Polymorphism and Composition

---

## Infix types

```amok
context type
version
    Decodable { type Self = Int }
version
    is[Decodable, Int]
version
    Int is Decodable
version
    Int is Decodable raises NumberError
version
    raises[Int is Decodable, NumberError]
version
    Tactic[NumberError] ?=> Int is Decodable
version
    Tactic[NumberError] ?=> (Decodable { type Self = Int })
```

---

### Infix types

```amok
context type
version
    Instant is Addable by Duration to Instant
version
    to[Instant is Addable by Duration, Instant]
version
    to[by[Instant is Addable, Duration], Instant]
version
    to[by[is[Instant, Addable], Duration], Instant]
version
    to[by[Addable { type Self = Instant }, Duration], Instant]
version
    to[Addable { type Self = Instant; type Operand = Duration }, Instant]
version
    Addable { type Self = Instant; type Operand = Duration; type Result = Instant }
version
    Instant is Addable by Duration to Instant
version
    Instant is Addable by Duration
```

---

## The Typeclass Designer's Dilemma

```amok
version
    trait Decodable[result]:
      def decode(text: Text): result
version
    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    object Decodable:
      given Text is Decodable = identity(_)

    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Int = ???

    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Int = _.toInt

    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Optional[Int] =
          if isValidInt(text) then text.toInt else Unset

    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Optional[Int] =
          if isValidInt(text) then text.toInt else Unset

    trait Decodable:
      type Self
      def decode(text: Text): Optional[Self]
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Int raises NumberError =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

    trait Decodable:
      type Self
      def decode(text: Text): Optional[Self]
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Int raises NumberError =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

    trait Decodable:
      type Self
      def decode(text: Text): Self raises NumberError
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Int raises NumberError =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

      given EmailAddress is Decodable:
        def decode(text: Text): EmailAddress raises EmailAddressError =
          EmailAddress.parse(text)

    trait Decodable:
      type Self
      def decode(text: Text): Self raises NumberError
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Int raises NumberError raises EmailAddressError =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

      given EmailAddress is Decodable:
        def decode(text: Text): EmailAddress raises NumberError raises EmailAddressError =
          EmailAddress.parse(text)

    trait Decodable:
      type Self
      def decode(text: Text): Self raises NumberError raises EmailAddressError
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text): Int raises NumberError =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

      given EmailAddress is Decodable:
        def decode(text: Text): EmailAddress raises EmailAddressError =
          EmailAddress.parse(text)

    trait Decodable:
      type Self
      def decode(text: Text): Self raises NumberError raises EmailAddressError
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Int is Decodable:
        def decode(text: Text)(using Tactic[NumberError]): Int =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

      given EmailAddress is Decodable:
        def decode(text: Text)(using Tactic[EmailAddressError]): EmailAddress =
          EmailAddress.parse(text)

    trait Decodable:
      type Self
      def decode(text: Text): Self raises NumberError raises EmailAddressError
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Tactic[NumberError] => Int is Decodable:
        def decode(text: Text): Int =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

      given Tactic[EmailAddressError] => EmailAddress is Decodable:
        def decode(text: Text): EmailAddress =
          EmailAddress.parse(text)

    trait Decodable:
      type Self
      def decode(text: Text): Self raises NumberError raises EmailAddressError
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Tactic[NumberError] => Int is Decodable:
        def decode(text: Text): Int =
          if isValidInt(text) then text.toInt
          else raise(NumberError(text))

      given Tactic[EmailAddressError] => EmailAddress is Decodable:
        def decode(text: Text): EmailAddress =
          EmailAddress.parse(text)

    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    object Decodable:
      given Text is Decodable = identity(_)

      given Tactic[NumberError] => Int is Decodable = text =>
        if isValidInt(text) then text.toInt
        else raise(NumberError(text))

      given Tactic[EmailAddressError] => EmailAddress is Decodable =
        EmailAddress.parse(_)

    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    trait Decodable:
      type Self
      def decode(text: Text): Self
version
    trait Decodable:
      type Self
      def decode(json: Json): Self
version
    trait Decodable:
      type Self
      type Form
      def decode(value: Form): Self
version
    trait Decodable extends Typeclass:
      type Form
      def decode(value: Form): Self
version
    trait Decodable extends Typeclass, Formal:
      def decode(value: Form): Self
```

---

### Composability

```amok
version
    import strategies.throwUnsafely

    val source: Path on Linux = % / "home" / "propensive" / "file.txt"
    source.read[Text]
version
    import strategies.throwUnsafely

    val source: Path on Linux = % / "home" / "propensive" / "image.jpg"
    source.read[Raster of Jpeg]
version
    import strategies.throwUnsafely

    val source: Path on Linux = % / "home" / "propensive" / "info.md"
    source.read[Md]
version
    import strategies.throwUnsafely

    val source: Path on Linux = % / "home" / "propensive" / "data.csv"
    source.read[Sheet]
version
    import strategies.throwUnsafely
    import dsvFormats.csv

    val source: Path on Linux = % / "home" / "propensive" / "data.csv"
    source.read[Sheet]
version
    import strategies.throwUnsafely

    val source: Path on Linux = % / "home" / "propensive" / "data.json"
    source.read[Json]
version
    import strategies.throwUnsafely

    val source: Path on Linux = % / "home" / "propensive" / "data.json"
    source.read[Json].as[MyData]
version
    import strategies.throwUnsafely

    val source = Classpath / "data.json"
    source.read[Json].as[MyData]
version
    import strategies.throwUnsafely

    val source = url"https://example.com/sample.json"
    source.read[Json].as[MyData]
version
    import strategies.throwUnsafely
    import internetAccess.enabled

    val source = url"https://example.com/sample.json"
    source.read[Json].as[MyData]
version
    import strategies.throwUnsafely
    import internetAccess.enabled

    val source = url"https://example.com/sample.json"

    summon[HttpUrl is Readable by Bytes]

    source.read[Json].as[MyData]
version
    import strategies.throwUnsafely
    import internetAccess.enabled

    val source = url"https://example.com/sample.json"

    summon[HttpUrl is Readable by Bytes]
    summon[Json is Aggregable by Bytes]

    source.read[Json].as[MyData]
version
    import strategies.throwUnsafely
    import internetAccess.enabled

    val source = url"https://example.com/sample.json"

    summon[HttpUrl is Readable by Text]
    summon[Json is Aggregable by Text]

    source.read[Json].as[MyData]
```

---

## Direct-style Scala

```amok
version
    def block[result](action: => result): result =
      setUp()
      val result = action
      tearDown()
      result
version
    def block[result](action: => result): result =
      setUp()
      val result = action
      tearDown()
      result

    block:
      doSomething()
version
    def block[result](action: Context => result): result =
      val context = setUp()
      val result = action(context)
      context.tearDown()
      result

    block: context =>
      doSomething()(context)
version
    def block[result](action: Context ?=> result): result =
      val context = setUp()
      val result = action(using context)
      context.tearDown()
      result

    block:
      doSomething()
version
    def block[result](action: (context: Context) ?=> result): result =
      val context = setUp()
      val result = action(using context)
      context.tearDown()
      result

    block:
      println(context)
      doSomething()
```

---

## Error handling

Let's take a filename, interpret it as a path, read its content as JSON and extract a
`Person` from it.

```amok
version
    def extract(filename: Text): Person = ???
version
    def extract(filename: Text): Person =
      filename.decode[Path on Linux]
version
    def extract(filename: Text): Person =
      filename.decode[Path on Linux].read[Json]
version
    def extract(filename: Text): Person =
      filename.decode[Path on Linux].read[Json].as[Person]
```

---

## Example

There are several possible failures:
- `_.decode[Path on Linux]` might fail if the path is invalid on Linux (`PathError`)
- `_.read[Json]` might fail if there's a disk I/O error (`IoError`)
- ...or if the content isn't valid JSON (`ParseError`)
- `.as[Person]` might fail if the JSON has the wrong schema (`JsonError`)

---

```amok
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      filename.decode[Path on Linux].read[Json].as[Person]
version
    import strategies.throwUnsafely

    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      filename.decode[Path on Linux].flatMap(_.read[Json].as[Person])
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      filename.decode[Path on Linux].flatMap(_.read[Json].map(_.as[Person]))
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Try[Person] =
      filename.decode[Path on Linux].flatMap(_.read[Json].map(_.as[Person]))
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Try[Person] =
      for path <- filename.decode[Path on Linux]
          json <- path.read[Json]
      yield json.as[Person]
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      unsafely:
        filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Optional[Person] =
      safely:
        filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text): Person =
      filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    def extract(filename: Text)
    : Person raises PathError raises IoError raises ParseError raises JsonError =

        filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError() extends Error(m"Could not read the person")

    def extract(filename: Text)
    : Person raises PathError raises IoError raises ParseError raises JsonError =

        filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError() extends Error(m"Could not read the person")

    def extract(filename: Text): Person raises ExtractError =
      filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError() extends Error(m"Could not read the person")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError() extends Error(m"Could not read the person")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case error: Error => ExtractError()
      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError() extends Error(m"Could not read the person")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError()
        case IoError(path, op, reason) => ExtractError()
        case ParseError(_, _, _)       => ExtractError()
        case JsonError(reason)         => ExtractError()

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Optional[Person] =
      recover:
        case PathError(reason, path)   => Unset
        case IoError(path, op, reason) => Out.println("I/O error!") yet Unset
        case ParseError(_, _, _)       => Unset
        case JsonError(reason)         => Person.default

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int, email: EmailAddress)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int, email: EmailAddress)

    given Tactic[EmailAddressError] => EmailAddress is Decodable in Json = ???

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int, email: EmailAddress)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError raises EmailAddressError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: Int, email: EmailAddress)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)
        case EmailAddressError(reason) => ExtractError(reason.communicate)

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: 0 ~ 130, email: EmailAddress)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)
        case EmailAddressError(reason) => ExtractError(reason.communicate)

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: 0 ~ 130, email: EmailAddress)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")
        case JsonError(reason)         => ExtractError(reason.communicate)
        case EmailAddressError(reason) => ExtractError(reason.communicate)
        case RangeError(_, _, _)       => ExtractError(m"the age was out of range")

      . within:
          filename.decode[Path on Linux].read[Json].as[Person]
version
    case class Person(name: Text, age: 0 ~ 130, email: EmailAddress)

    case class ExtractError(reason: Message)
    extends Error(m"Could not read the person because $reason")

    def extract(filename: Text): Person raises ExtractError =
      mitigate:
        case PathError(reason, path)   => ExtractError(m"the path was bad")
        case IoError(path, op, reason) => ExtractError(reason.communicate)
        case ParseError(_, _, _)       => ExtractError(m"the JSON did not parse")

      . within:
          val json = filename.decode[Path on Linux].read[Json]
          json.as[Person]
version
    val json = filename.decode[Path on Linux].read[Json]
    json.as[Person]
version
    val json = filename.decode[Path on Linux].read[Json]

    validate(ExtractError()):
      case JsonError(reason)         => accrual.add(reason.communicate)
      case EmailAddressError(reason) => accrual.add(reason.communicate)
      case RangeError(_, _, _)       => accrual.add(m"the age was out of range")

    . within:
        json.as[Person]
version
    val json = filename.decode[Path on Linux].read[Json]

    validate[JsonPointer](ExtractError()):
      case JsonError(reason)         => accrual.add(reason.communicate, focus)
      case EmailAddressError(reason) => accrual.add(reason.communicate, focus)
      case RangeError(_, _, _)       => accrual.add(m"the age was out of range", focus)

    . within:
        json.as[Person]
```
---

```amok
version
    class Json():
      def as[result]: result
version
    class Json():
      def as[result: Decodable in Json]: result
version
    class Json():
      def as[result: Decodable in Json]: result raises JsonError
version
    class Json():
      def as[result: Decodable in Json]: result raises JsonError tracks JsonPointer
```
---

## Ordinals

The two most difficult problems in computer science:

 - naming things
 - cache invalidation
 - off-by-one errors

---

## Ordinals

Let's use different types for _cardinal_ and _ordinal_ numbers

- Use `Int` for _cardinal_ numbers, like the size of a collection
- Use `Ordinal` for _ordinal_ numbers, like `Array` indices

---

### New approach

- let `Prim`, `Sec`, `Ter`, `Quat`, `Quin`, `Sen` be the first ordinal numbers
  - there is no "zeroth" / "first" ambiguity
  - we always know which element these refer to
  - most of the time we don't need to refer to an `Ordinal` by name

---

## New restrictions

```amok
version
    val n = 2 + 1
version
    val n: Int = 2 + 1
version
    val n: Int = Sec + 1 // type error
version
    val n: Ordinal = Sec + 1
version
    val n: Ordinal = Sec + Prim // type error
version
    val n: Ordinal = Sec - Prim // type error
version
    val n: Int = Sec - Prim
version
    val n: Int = Sec - 1 // type error
version
    val n: Ordinal = Sec - 1
version
    val n = 2*Sec // type error
```

---

## Why it _helps_:

In numeric expressions,

- _some_ values will get a different type
- _some_ of the arithmetic operations may change operand types
- _some_ of those operations may no longer be valid
- ...but only the ones which don't make sense!

---

## The `cli` Bundle

* interactive CLI applications
* rendering tree- and DAG-like data in the terminal
* tab-completions for CLI applications
* tabulating data for the terminal
* bundling a Scala program for distribution
* instantaneous startup for CLI apps
* executing shell commands
* filesystem monitoring

---

## The `sci` Bundle

* representations of physical quantities
* quantized quantities (e.g. feet and inches)
* datatypes for working with directed acyclic graphs
* representations of complex numbers
* representations of chemical symbols
* safe arithmetic tools
* opaque types for unsigned arithmetic
* vector and matrix algebra

---

How far will a car traveling at 100km/h and accelerating at 0.5m/s² travel in 1 minute?

```amok
version
    val u = 100.0  // car traveling at 100km/h
version
    val u = 100.0  // car traveling at 100km/h
    val a = 0.5    // acceleration of 0.5m/s²
version
    val u = 100.0  // car traveling at 100km/h
    val a = 0.5    // acceleration of 0.5m/s²
    val t = 1.0    // one minute
version
    val u = 100.0  // car traveling at 100km/h
    val a = 0.5    // acceleration of 0.5m/s²
    val t = 1.0    // one minute

    val s = u*t + 0.5*a*t*t
version
    val u = 100.0*Kilo(Metre)/Hour
    val a = 0.5    // acceleration of 0.5m/s²
    val t = 1.0    // one minute

    val s = u*t + 0.5*a*t*t
version
    val u = 100.0*Kilo(Metre)/Hour
    val a = 0.5*Metre/Second/Second
    val t = 1.0    // one minute

    val s = u*t + 0.5*a*t*t
version
    val u = 100.0*Kilo(Metre)/Hour
    val a = 0.5*Metre/Second/Second
    val t = 1.0*Minute

    val s = u*t + 0.5*a*t*t
version
    val u = 100.0*Kilo(Metre)/Hour
    val a = 0.5*Metre/Second/Second
    val t = 1.0*Minute

    val s: Quantity[Metres[1]] = u*t + 0.5*a*t*t
version
    val u: Quantity[Metres[1] & Hours[-1]] = 100.0*Kilo(Metre)/Hour
    val a: Quantity[Metres[1] & Seconds[-2]] = 0.5*Metre/Second/Second
    val t: Quantity[Seconds[1]] = 1.0*Minute

    val s: Quantity[Metres[1]] = u*t + 0.5*a*t*t
version
    val u = 100.0*Kilo(Metre)/Hour
    val a = 0.5*Metre/Second/Second
    val t = 1.0*Minute

    val s = u*t + 0.5*a*t*t
```

---

## The `test` Bundle

* unit test runner
* benchmarking
* structured comparison of values
* test compiletime error messages
* test coverage
* provision of randomized data

---


## Compiletime tests

```amok
version
    test(m"check that 2 + 2 equals 4"):
      2 + 2
    . assert(_ == 4)
version
    test(m"check that 2 + 2 equals 4"):
      2 + 2
    . assert(_ == 4)

    test(m"check that 2 + 2 equals 4 at compiletime"):
      val x: 4 = 2 + 2
    . assert()
version
    test(m"check that 2 + 2 equals 4"):
      2 + 2
    . assert(_ == 4)

    test(m"check that 2 + 2 equals 4 at compiletime"):
      val x: 4 = 2 + 2
    . assert()

    test(m"check that 2 + 2 does not equal 5"):
      val x: 5 = 2 + 2
    . assert()
version
    test(m"check that 2 + 2 equals 4"):
      2 + 2
    . assert(_ == 4)

    test(m"check that 2 + 2 equals 4 at compiletime"):
      val x: 4 = 2 + 2
    . assert()

    test(m"check that 2 + 2 does not equal 5"):
      demilitarize:
        val x: 5 = 2 + 2
    . assert()
version
    test(m"check that 2 + 2 equals 4"):
      2 + 2
    . assert(_ == 4)

    test(m"check that 2 + 2 equals 4 at compiletime"):
      val x: 4 = 2 + 2
    . assert()

    test(m"check that 2 + 2 does not equal 5"):
      demilitarize:
        val x: 5 = 2 + 2
      . messages
    . assert()
version
    test(m"check that 2 + 2 equals 4"):
      2 + 2
    . assert(_ == 4)

    test(m"check that 2 + 2 equals 4 at compiletime"):
      val x: 4 = 2 + 2
    . assert()

    test(m"check that 2 + 2 does not equal 5"):
      demilitarize:
        val x: 5 = 2 + 2
      . messages
    . assert(_.length > 0)
version
    test(m"check that 2 + 2 does not equal 5"):
      demilitarize:
        val x: 5 = 2 + 2
      . messages
    . assert(_.length > 0)
version
    test(m"check that incompatible quantities cannot be added"):
      demilitarize:
        val x = 2*Metre + 2*Watt
      . messages
    . assert(_.length > 0)
version
    test(m"check that incompatible quantities cannot be added"):
      demilitarize:
        val x = 2*Metre + 2*Watt
      . messages
    . assert(_ == List(t"""quantitative: the left operand represents distance,
                           but the right operand represents power; these are
                           incompatible physical quantities"""))
```

---

## Test rigs

```amok
version
    test(m"test a CLI application"):
      @main
      def run(): Unit = cli:
        arguments match
          case Help() :: _ => execute(Out.println(msg) yet Exit.Ok)
          case _           => execute(Exit.Fail(1))

      // invoke(t"help")

    . assert(_ == "Helpful text")
version
    test(m"test a CLI application"):
      val app = cliRig:
        @main
        def run(): Unit = cli:
          arguments match
            case Help() :: _ => execute(Out.println(msg) yet Exit.Ok)
            case _           => execute(Exit.Fail(1))

      // invoke(t"help")

    . assert(_ == "Helpful text")
version
    test(m"test a CLI application"):
      val app = cliRig:
        cli:
          arguments match
            case Help() :: _ => execute(Out.println(msg) yet Exit.Ok)
            case _           => execute(Exit.Fail(1))

      // invoke(t"help")

    . assert(_ == "Helpful text")
version
    test(m"test a CLI application"):
      val app = cliRig:
        '{  cli:
              arguments match
                case Help() :: _ => execute(Out.println(msg) yet Exit.Ok)
                case _           => execute(Exit.Fail(1))  }

      // invoke(t"help")

    . assert(_ == "Helpful text")
version
    test(m"test a CLI application"):
      val app = cliRig:
        '{  cli:
              arguments match
                case Help() :: _ => execute(Out.println(msg) yet Exit.Ok)
                case _           => execute(Exit.Fail(1))  }

      app.invoke(t"help")

    . assert(_ == "Helpful text")
version
    for msg <- List("Hello world!", "Привет, мир!", "გამარჯობა, მსოფლიო!") do
      test(m"test a CLI application with $msg"):
        val app = cliRig:
          '{  cli:
                arguments match
                  case Help() :: _ => execute(Out.println(msg) yet Exit.Ok)
                  case _           => execute(Exit.Fail(1))  }

        app.invoke(t"help")

      . assert(_ == msg)
version
    for msg <- List("Hello world!", "Привет, мир!", "გამარჯობა, მსოფლიო!") do
      test(m"test a CLI application with $msg"):
        val app = cliRig:
          '{  cli:
                arguments match
                  case Help() :: _ => execute(Out.println($msg) yet Exit.Ok)
                  case _           => execute(Exit.Fail(1))  }

        app.invoke(t"help")

      . assert(_ == msg)
```

---

## The `tool` Bundle

* typesafe programmatic invocations of the Scala compiler
* compiler-checked syntax highlighting
* classpath manipulation
* TASTy analysis
* programmatic interface to Git
* plugin for compile-time package-shading
* Java bytecode decompiler

---

## The `web` Bundle

* correctly represent URLs and other network values
* typesafe generation of HTML
* generate validated forms from case classes
* HTTP client and server
* Markdown engine
* SVG generation
* Multilingual data structures
* support for MIME types
* read TTF/OTF font files
* send emails
* work with CSS
* read and process JPEGs, GIFs, PNGs and BMPs

---

## Thank you

- Check out the Soundness website: https://soundness.dev/
- Ask me about consultancy in Scala 3
